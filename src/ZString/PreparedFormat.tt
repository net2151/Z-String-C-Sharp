<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System;
using System.Text;
using System.Buffers;

namespace Cysharp.Text
{
<# foreach(var utf in utfTypes) { var isUtf16 = (utf == "Utf16"); #>
<# for(var i = 1; i <= TypeParamMax; i++) { #>
    public sealed partial class <#= utf #>PreparedFormat<<#= CreateTypeArgument(i) #>>
    {
        public string FormatString { get; }
        public int MinSize { get; }

        readonly FormatSegment[] segments;

        public <#= utf #>PreparedFormat(string format)
        {
            this.FormatString = format;
            this.segments = PreparedFormatHelper.Parse(format, <#= (utf == "Utf16" ? false : true).ToString().ToLower() #>);

            var size = 0;
            foreach (var item in segments)
            {
                if (!item.IsFormatArgument)
                {
                    size += item.Count;
                }
            }
            this.MinSize = size;
        }

        public string Format(<#= CreateParameters(i) #>)
        {
            var sb = new <#= utf #>ValueStringBuilder(true);
            try
            {
                FormatTo(ref sb, <#= CreateParameterNames(i) #>);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        public void FormatTo<TBufferWriter>(ref TBufferWriter sb, <#= CreateParameters(i) #>)
            where TBufferWriter : IBufferWriter<<#= isUtf16 ? "char" : "byte" #>>
        {
            var formatSpan = FormatString.AsSpan();

            foreach (var item in segments)
            {
                switch (item.FormatIndex)
                {
                    case FormatSegment.NotFormatIndex:
                        {
                            var strSpan = formatSpan.Slice(item.Offset, item.Count);
<# if(isUtf16) { #>
                            var span = sb.GetSpan(item.Count);
                            strSpan.TryCopyTo(span);
                            sb.Advance(item.Count);
<# } else { #>
                            var size = Encoding.UTF8.GetMaxByteCount(item.Count);
                            var span = sb.GetSpan(size);
                            var count = Encoding.UTF8.GetBytes(strSpan, span);
                            sb.Advance(count);
<# } #>
                            break;
                        }
<# for(var j = 0; j < i; j++) { #>
                    case <#= j #>:
                        {
                            <#= utf #>FormatHelper.FormatTo(ref sb, arg<#= j + 1 #>, item.Alignment, <#= isUtf16 ? "formatSpan.Slice(item.Offset, item.Count)" : "item.StandardFormat" #>, nameof(arg<#= j + 1 #>));
                            break;
                        }
<# } // for(j) #>
                    default:
                        break;
                }
            }
        }
    }
<# } // for(i) #>
<# } // foreach(utf) #>
}
