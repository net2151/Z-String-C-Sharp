<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="T4Common.t4" once="true" #>
using System;
using System.Buffers;
using System.Runtime.CompilerServices;

using static Cysharp.Text.Utf8ValueStringBuilder;

namespace Cysharp.Text
{
    public static partial class ZString
    {
<# for(var i = 1; i <= TypeParamMax; i++) { #>
        /// <summary>Replaces one or more format items in a string with the string representation of some specified values.</summary>
        public static void Utf8Format<<#= CreateTypeArgument(i) #>>(IBufferWriter<byte> bufferWriter, string format, <#= CreateParameters(i) #>)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }
            
            var copyFrom = 0;
            for (int i = 0; i < format.Length; i++)
            {
                var c = format[i];
                if (c == '{')
                {
                    // escape.
                    if (i == format.Length - 1)
                    {
                        throw new FormatException("invalid format");
                    }

                    if (i != format.Length && format[i + 1] == '{')
                    {
                        var size = i - copyFrom;
                        var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(size));
                        var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, size), buffer);
                        bufferWriter.Advance(written);
                        i = i + 1; // skip escaped '{'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                        var size = i - copyFrom;
                        var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(size));
                        var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, size), buffer);
                        bufferWriter.Advance(written);
                    }

                    // try to find range
                    var indexParse = FormatParser.Parse(format, i);
                    copyFrom = indexParse.LastIndex;
                    i = indexParse.LastIndex - 1;
                    var writeFormat = StandardFormat.Parse(indexParse.FormatString);
                    switch (indexParse.Index)
                    {
<# for(var j = 0; j < i; j++) { #>
                        case <#= j #>:
                            Utf8FormatInternal(bufferWriter, arg<#= j + 1 #>, indexParse.Alignment, writeFormat, nameof(arg<#= j + 1 #>));
                            continue;
<# } #>
                        default:
                            ExceptionUtil.ThrowFormatException();
                            break;
                    }

                    ExceptionUtil.ThrowFormatException();
                }
                else if (c == '}')
                {
                    if (i + 1 < format.Length && format[i + 1] == '}')
                    {
                        var size = i - copyFrom;
                        var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(size));
                        var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, size), buffer);
                        bufferWriter.Advance(written);
                        i = i + 1; // skip escaped '}'
                        copyFrom = i;
                        continue;
                    }
                    else
                    {
                    	ExceptionUtil.ThrowFormatException();
                    }
                }
            }

            {
                // copy final string
                var copyLength = format.Length - copyFrom;
                if (copyLength > 0)
                {
                    var buffer = bufferWriter.GetSpan(UTF8NoBom.GetMaxByteCount(copyLength));
                    var written = UTF8NoBom.GetBytes(format.AsSpan(copyFrom, copyLength), buffer);
                    bufferWriter.Advance(written);
                }
            }
        }

<# } #>

        static void Utf8FormatInternal<T>(IBufferWriter<byte> bufferWriter, T arg, int width, StandardFormat format, string argName)
        {
            if (width <= 0) // leftJustify
            {
                width *= -1;

                var buffer = bufferWriter.GetSpan();

                if (!FormatterCache<T>.TryFormatDelegate(arg, buffer, out var written, format))
                {
                    bufferWriter.Advance(0);
                    buffer = bufferWriter.GetSpan(Math.Max(buffer.Length + 1, written));

                    if (!FormatterCache<T>.TryFormatDelegate(arg, buffer, out written, format))
                    {
                        ExceptionUtil.ThrowArgumentException(argName);
                    }
                }

                bufferWriter.Advance(written);

                int padding = width - written;
                if (width > 0 && padding > 0)
                {
                    // TODO Append(' ', padding);
                    bufferWriter.GetSpan(padding).Fill((byte)' ');  // TODO Fill Method is too slow.
                    bufferWriter.Advance(padding);
                }
            }
            else // rightJustify
            {
                if (typeof(T) == typeof(string))
                {
                    var s = Unsafe.As<string>(arg);
                    int padding = width - s.Length;
                    if (padding > 0)
                    {
                        // TODO Append(' ', padding);
                        bufferWriter.GetSpan(padding).Fill((byte)' '); // TODO Fill Method is too slow.
                        bufferWriter.Advance(padding);
                    }

                    ZString.AppendChars(ref bufferWriter, s.AsSpan());
                }
                else
                {
                    Span<byte> s = stackalloc byte[typeof(T).IsValueType ? Unsafe.SizeOf<T>() * 8 : 1024];

                    if (!FormatterCache<T>.TryFormatDelegate(arg, s, out var charsWritten, format))
                    {
                        s = stackalloc byte[s.Length * 2];
                        if (!FormatterCache<T>.TryFormatDelegate(arg, s, out charsWritten, format))
                        {
                            ExceptionUtil.ThrowArgumentException(argName);
                        }
                    }

                    int padding = width - charsWritten;
                    if (padding > 0)
                    {
                        // TODO Append(' ', padding);
                        bufferWriter.GetSpan(padding).Fill((byte)' '); // TODO Fill Method is too slow.
                        bufferWriter.Advance(padding);
                    }

                    s.CopyTo(bufferWriter.GetSpan(charsWritten));
                    bufferWriter.Advance(charsWritten);
                }
            }
        }
    
    }
}
